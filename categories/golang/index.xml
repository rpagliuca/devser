<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on /dev/ser</title>
    <link>https://devser.com.br/categories/golang/</link>
    <description>Recent content in Golang on /dev/ser</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 26 May 2020 15:49:55 -0300</lastBuildDate><atom:link href="https://devser.com.br/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Streaming MySQL changes to MongoDB with go-mysql</title>
      <link>https://devser.com.br/posts/streaming-mysql-changes-to-mongodb-using-go-mysql/</link>
      <pubDate>Tue, 26 May 2020 15:49:55 -0300</pubDate>
      
      <guid>https://devser.com.br/posts/streaming-mysql-changes-to-mongodb-using-go-mysql/</guid>
      <description>I&amp;rsquo;ve setup a proof-of-concept environment with docker-compose, for streaming MySQL data changes into a MongoDB collection.
It&amp;rsquo;s based on the great go-mysql library.
You can check out the project code in here: https://github.com/rpagliuca/stream-mysql-to-mongodb-with-go
Also, here is a videocast of the project up and running:   </description>
    </item>
    
    <item>
      <title>Serverless do zero</title>
      <link>https://devser.com.br/posts/serverless-do-zero/</link>
      <pubDate>Sat, 23 May 2020 09:18:17 -0300</pubDate>
      
      <guid>https://devser.com.br/posts/serverless-do-zero/</guid>
      <description>Introdução Antes desse artigo, eu nunca havia programado nenhuma aplicação serverless do zero. Entretanto, já tive algum contato com aplicações desse tipo:
 Há uns 2 anos instalei, na AWS, uma aplicação de redimensionamento de imagens com AWS Lambda Functions (https://aws.amazon.com/pt/solutions/implementations/serverless-image-handler/). Ah, também já instalei Lambda Functions para limpar o cache do CloudFront, que é chamado em um dos stages do AWS Code Pipeline de um de nossos projetos.  Mas minha experiência terminava aí.</description>
    </item>
    
    <item>
      <title>Comparando a perfomance de Go, .NET e PHP</title>
      <link>https://devser.com.br/posts/comparando-a-perfomance-de-go-dotnet-e-php/</link>
      <pubDate>Wed, 21 Aug 2019 11:18:05 -0300</pubDate>
      
      <guid>https://devser.com.br/posts/comparando-a-perfomance-de-go-dotnet-e-php/</guid>
      <description>Com contribução de Felipe Finhane e Marcio Zacarias.
Cenários comparados Utilizando o programa wrk, calculei a capacidade de requisições por segundo das seguintes variações de ambiente:
   Cenário Linguagem Servidor Framework Docker Imagem Docker     Go Go Embutido Não Não N/A   .NET .NET Embutido Não Sim microsoft/dotnet:2.2-aspnetcore-runtime   PHP-1 PHP Embutido Não Não N/A   PHP-2 PHP Nginx Não Sim N/A   PHP-3 PHP Nginx Symfony Sim richarvey/nginx-php-fpm   PHP-4 PHP Nginx Symfony Sim (private)   Static N/A Nginx Não Sim nginxdemos/hello   Clojure Clojure JVM Não Não N/A    Todos os ambientes foram configurados para retornar uma única linha contendo repetições da string &amp;ldquo;Hello, world!</description>
    </item>
    
  </channel>
</rss>
