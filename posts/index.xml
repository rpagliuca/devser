<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on /dev/ser (ou não?!)</title>
    <link>https://rpagliuca.github.io/devser/posts/</link>
    <description>Recent content in Posts on /dev/ser (ou não?!)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sat, 08 Jun 2019 09:04:34 -0300</lastBuildDate>
    
	<atom:link href="https://rpagliuca.github.io/devser/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Migração do blog para Hugo (gohugo)</title>
      <link>https://rpagliuca.github.io/devser/posts/migracao-para-gohugo/</link>
      <pubDate>Sat, 08 Jun 2019 09:04:34 -0300</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/migracao-para-gohugo/</guid>
      <description>Hoje migrei a plataforma deste blog de Wordpress para Hugo (https://gohugo.io/), pelos seguintes motivos:
 Aumento de performance Redução de custos Abertura do código-fonte: https://github.com/rpagliuca/devser  Na verdade Hugo não é uma plataforma, e sim, uma biblioteca capaz de produzir um blog estático, a partir de arquivos declarativos .yml e markdown. Uma outra biblioteca bastante conhecida, similar ao Hugo, é a Jekyll (https://jekyllrb.com/). Como agora o blog ficou estático, estará hospedado na plataforma Github Pages.</description>
    </item>
    
    <item>
      <title>Deixe seu MySQL muito mais rápido rodando na memória RAM</title>
      <link>https://rpagliuca.github.io/devser/posts/deixe-seu-mysql-muito-mais-rapido-rodando-na-memoria-ram/</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/deixe-seu-mysql-muito-mais-rapido-rodando-na-memoria-ram/</guid>
      <description>Muitas vezes, o gargalo de uma importação de banco, ou execução de queries SQL é o tempo de escrita e leitura no disco rígido. Sabendo disso, uma maneira bacana de deixar o MySQL rapidão é deixar o banco inteiro armazenado na memória RAM, para nunca precisarmos acessar o disco rígido.
Claro que esse armazenamento é volátil, portanto é recomendado apenas para ambiente de desenvolvimento, onde muitas vezes um script ou importação de dump é executado múltiplas vezes por dia, tomando preciosos minutos do desenvolvedor.</description>
    </item>
    
    <item>
      <title>Aprendizado de máquina com Python &#43; Tensor Flow</title>
      <link>https://rpagliuca.github.io/devser/posts/aprendizado-de-maquina-com-python-tensor-flow/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/aprendizado-de-maquina-com-python-tensor-flow/</guid>
      <description>Seguem passos para configurar o ambiente do Tensor Flow no Debian ou Ubuntu:
É incrivelmente fácil, já que o Google fez um container para o docker com todas as bibliotecas pré-instaladas.
Siga os seguintes passos:
1) Instalar docker
2) Rodar no terminal sudo docker run -it -p 8888:8888 gcr.io/tensorflow/tensorflow
3) Abrir link do jupyter (localhost:8888/…) que for exibido no terminal
4) Acompanhar os tutoriais interativos de Tensor Flow no navegador</description>
    </item>
    
    <item>
      <title>Compilador para computador SAP-1</title>
      <link>https://rpagliuca.github.io/devser/posts/compilador-para-computador-sap-1/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/compilador-para-computador-sap-1/</guid>
      <description>A pedidos do amigo Antonio Souza, segue código-fonte do compilador para computador SAP-1 utilizado no artigo http://devser.com.br/2013/10/simulando-um-computador-sap-1-simple-as-possible-1/.
Desenvolvi esse compilador em PHP, para poder disponibilizá-lo online juntamente ao referido artigo. A parte principal do compilador é dada pelas primeiras 25 linhas do código. O restante se refere simplesmente ao próprio formulário HTML para receber um texto e convertê-lo em binário.
O script abaixo encontra-se funcionando no endereço http://devser.com.br/misc/sap-compiler.
&amp;lt;?php if (isset($_POST[&amp;#39;code&amp;#39;]) and $_POST[&amp;#39;code&amp;#39;]) { $uniqid = uniqid(&amp;#39;&amp;#39;, true); $output_atmel = &amp;#34;out/$uniqid.</description>
    </item>
    
    <item>
      <title>Medindo performance e gargalos de uma página PHP com KCacheGrind &#43; XDebug</title>
      <link>https://rpagliuca.github.io/devser/posts/medindo-performance-e-gargalos-de-uma-pagina-php/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/medindo-performance-e-gargalos-de-uma-pagina-php/</guid>
      <description>Introdução “Conheces teu inimigo e conhece-te a ti mesmo” — Sun Tzu (a.k.a “Conheça o gargalo de seu script e atue para otimizá-lo”)
Utilizando KCacheGrind + XDebug no PHP, podemos medir quais métodos de um script são os principais “inimigos” de tempo de processamento, o gargalo da execução.
Normalmente, das centenas de métodos que são chamados em um único script, pouquíssimos deles são responsáveis por mais de 90% do processamento, portanto pequenos ajustes nos lugares certos fazem uma grande diferença no tempo de resposta do seu script.</description>
    </item>
    
    <item>
      <title>Criando plugins para a biblioteca de templates Smarty do PHP</title>
      <link>https://rpagliuca.github.io/devser/posts/criando-plugins-para-a-biblioteca-de-templates-smarty-do-php/</link>
      <pubDate>Thu, 16 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://rpagliuca.github.io/devser/posts/criando-plugins-para-a-biblioteca-de-templates-smarty-do-php/</guid>
      <description>Introdução ao Smarty A biblioteca de template Smarty é mais uma ferramenta para auxiliar a separação de camadas de uma aplicação PHP. Mais especificamente, essa biblioteca normalmente é utilizada para fazer a separação entre arquivos das camadas Controller e View.
O Smarty processa arquivos de template, tipicamente com extensão .tpl, injetando variáveis PHP e retornando o conteúdo renderizado. Um arquivo simples de template do Smarty tem a seguinte forma:</description>
    </item>
    
  </channel>
</rss>